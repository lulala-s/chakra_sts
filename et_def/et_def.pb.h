// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: et_def.proto

#ifndef PROTOBUF_INCLUDED_et_5fdef_2eproto
#define PROTOBUF_INCLUDED_et_5fdef_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_et_5fdef_2eproto 

namespace protobuf_et_5fdef_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_et_5fdef_2eproto
namespace ChakraProtoMsg {
class AttributeProto;
class AttributeProtoDefaultTypeInternal;
extern AttributeProtoDefaultTypeInternal _AttributeProto_default_instance_;
class BoolList;
class BoolListDefaultTypeInternal;
extern BoolListDefaultTypeInternal _BoolList_default_instance_;
class BytesList;
class BytesListDefaultTypeInternal;
extern BytesListDefaultTypeInternal _BytesList_default_instance_;
class DoubleList;
class DoubleListDefaultTypeInternal;
extern DoubleListDefaultTypeInternal _DoubleList_default_instance_;
class Fixed32List;
class Fixed32ListDefaultTypeInternal;
extern Fixed32ListDefaultTypeInternal _Fixed32List_default_instance_;
class Fixed64List;
class Fixed64ListDefaultTypeInternal;
extern Fixed64ListDefaultTypeInternal _Fixed64List_default_instance_;
class FloatList;
class FloatListDefaultTypeInternal;
extern FloatListDefaultTypeInternal _FloatList_default_instance_;
class GlobalMetadata;
class GlobalMetadataDefaultTypeInternal;
extern GlobalMetadataDefaultTypeInternal _GlobalMetadata_default_instance_;
class IOInfo;
class IOInfoDefaultTypeInternal;
extern IOInfoDefaultTypeInternal _IOInfo_default_instance_;
class Int32List;
class Int32ListDefaultTypeInternal;
extern Int32ListDefaultTypeInternal _Int32List_default_instance_;
class Int64List;
class Int64ListDefaultTypeInternal;
extern Int64ListDefaultTypeInternal _Int64List_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Sfixed32List;
class Sfixed32ListDefaultTypeInternal;
extern Sfixed32ListDefaultTypeInternal _Sfixed32List_default_instance_;
class Sfixed64List;
class Sfixed64ListDefaultTypeInternal;
extern Sfixed64ListDefaultTypeInternal _Sfixed64List_default_instance_;
class Sint32List;
class Sint32ListDefaultTypeInternal;
extern Sint32ListDefaultTypeInternal _Sint32List_default_instance_;
class Sint64List;
class Sint64ListDefaultTypeInternal;
extern Sint64ListDefaultTypeInternal _Sint64List_default_instance_;
class StringList;
class StringListDefaultTypeInternal;
extern StringListDefaultTypeInternal _StringList_default_instance_;
class Tensor;
class TensorDefaultTypeInternal;
extern TensorDefaultTypeInternal _Tensor_default_instance_;
class Uint32List;
class Uint32ListDefaultTypeInternal;
extern Uint32ListDefaultTypeInternal _Uint32List_default_instance_;
class Uint64List;
class Uint64ListDefaultTypeInternal;
extern Uint64ListDefaultTypeInternal _Uint64List_default_instance_;
}  // namespace ChakraProtoMsg
namespace google {
namespace protobuf {
template<> ::ChakraProtoMsg::AttributeProto* Arena::CreateMaybeMessage<::ChakraProtoMsg::AttributeProto>(Arena*);
template<> ::ChakraProtoMsg::BoolList* Arena::CreateMaybeMessage<::ChakraProtoMsg::BoolList>(Arena*);
template<> ::ChakraProtoMsg::BytesList* Arena::CreateMaybeMessage<::ChakraProtoMsg::BytesList>(Arena*);
template<> ::ChakraProtoMsg::DoubleList* Arena::CreateMaybeMessage<::ChakraProtoMsg::DoubleList>(Arena*);
template<> ::ChakraProtoMsg::Fixed32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Fixed32List>(Arena*);
template<> ::ChakraProtoMsg::Fixed64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Fixed64List>(Arena*);
template<> ::ChakraProtoMsg::FloatList* Arena::CreateMaybeMessage<::ChakraProtoMsg::FloatList>(Arena*);
template<> ::ChakraProtoMsg::GlobalMetadata* Arena::CreateMaybeMessage<::ChakraProtoMsg::GlobalMetadata>(Arena*);
template<> ::ChakraProtoMsg::IOInfo* Arena::CreateMaybeMessage<::ChakraProtoMsg::IOInfo>(Arena*);
template<> ::ChakraProtoMsg::Int32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Int32List>(Arena*);
template<> ::ChakraProtoMsg::Int64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Int64List>(Arena*);
template<> ::ChakraProtoMsg::Node* Arena::CreateMaybeMessage<::ChakraProtoMsg::Node>(Arena*);
template<> ::ChakraProtoMsg::Sfixed32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Sfixed32List>(Arena*);
template<> ::ChakraProtoMsg::Sfixed64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Sfixed64List>(Arena*);
template<> ::ChakraProtoMsg::Sint32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Sint32List>(Arena*);
template<> ::ChakraProtoMsg::Sint64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Sint64List>(Arena*);
template<> ::ChakraProtoMsg::StringList* Arena::CreateMaybeMessage<::ChakraProtoMsg::StringList>(Arena*);
template<> ::ChakraProtoMsg::Tensor* Arena::CreateMaybeMessage<::ChakraProtoMsg::Tensor>(Arena*);
template<> ::ChakraProtoMsg::Uint32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Uint32List>(Arena*);
template<> ::ChakraProtoMsg::Uint64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Uint64List>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ChakraProtoMsg {

enum NodeType {
  INVALID_NODE = 0,
  METADATA_NODE = 1,
  MEM_LOAD_NODE = 2,
  MEM_STORE_NODE = 3,
  COMP_NODE = 4,
  COMM_SEND_NODE = 5,
  COMM_RECV_NODE = 6,
  COMM_COLL_NODE = 7,
  NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NodeType_IsValid(int value);
const NodeType NodeType_MIN = INVALID_NODE;
const NodeType NodeType_MAX = COMM_COLL_NODE;
const int NodeType_ARRAYSIZE = NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeType_descriptor();
inline const ::std::string& NodeType_Name(NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeType_descriptor(), value);
}
inline bool NodeType_Parse(
    const ::std::string& name, NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeType>(
    NodeType_descriptor(), name, value);
}
enum CollectiveCommType {
  ALL_REDUCE = 0,
  REDUCE = 1,
  ALL_GATHER = 2,
  GATHER = 3,
  SCATTER = 4,
  BROADCAST = 5,
  ALL_TO_ALL = 6,
  REDUCE_SCATTER = 7,
  REDUCE_SCATTER_BLOCK = 8,
  BARRIER = 9,
  CollectiveCommType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CollectiveCommType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CollectiveCommType_IsValid(int value);
const CollectiveCommType CollectiveCommType_MIN = ALL_REDUCE;
const CollectiveCommType CollectiveCommType_MAX = BARRIER;
const int CollectiveCommType_ARRAYSIZE = CollectiveCommType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CollectiveCommType_descriptor();
inline const ::std::string& CollectiveCommType_Name(CollectiveCommType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CollectiveCommType_descriptor(), value);
}
inline bool CollectiveCommType_Parse(
    const ::std::string& name, CollectiveCommType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CollectiveCommType>(
    CollectiveCommType_descriptor(), name, value);
}
// ===================================================================

class AttributeProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.AttributeProto) */ {
 public:
  AttributeProto();
  virtual ~AttributeProto();

  AttributeProto(const AttributeProto& from);

  inline AttributeProto& operator=(const AttributeProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttributeProto(AttributeProto&& from) noexcept
    : AttributeProto() {
    *this = ::std::move(from);
  }

  inline AttributeProto& operator=(AttributeProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttributeProto& default_instance();

  enum ValueCase {
    kDoubleVal = 3,
    kDoubleList = 4,
    kFloatVal = 5,
    kFloatList = 6,
    kInt32Val = 7,
    kInt32List = 8,
    kInt64Val = 9,
    kInt64List = 10,
    kUint32Val = 11,
    kUint32List = 12,
    kUint64Val = 13,
    kUint64List = 14,
    kSint32Val = 15,
    kSint32List = 16,
    kSint64Val = 17,
    kSint64List = 18,
    kFixed32Val = 19,
    kFixed32List = 20,
    kFixed64Val = 21,
    kFixed64List = 22,
    kSfixed32Val = 23,
    kSfixed32List = 24,
    kSfixed64Val = 25,
    kSfixed64List = 26,
    kBoolVal = 27,
    kBoolList = 28,
    kStringVal = 29,
    kStringList = 30,
    kBytesVal = 31,
    kBytesList = 32,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttributeProto* internal_default_instance() {
    return reinterpret_cast<const AttributeProto*>(
               &_AttributeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AttributeProto* other);
  friend void swap(AttributeProto& a, AttributeProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttributeProto* New() const final {
    return CreateMaybeMessage<AttributeProto>(NULL);
  }

  AttributeProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AttributeProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AttributeProto& from);
  void MergeFrom(const AttributeProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributeProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string doc_string = 2;
  void clear_doc_string();
  static const int kDocStringFieldNumber = 2;
  const ::std::string& doc_string() const;
  void set_doc_string(const ::std::string& value);
  #if LANG_CXX11
  void set_doc_string(::std::string&& value);
  #endif
  void set_doc_string(const char* value);
  void set_doc_string(const char* value, size_t size);
  ::std::string* mutable_doc_string();
  ::std::string* release_doc_string();
  void set_allocated_doc_string(::std::string* doc_string);

  // double double_val = 3;
  private:
  bool has_double_val() const;
  public:
  void clear_double_val();
  static const int kDoubleValFieldNumber = 3;
  double double_val() const;
  void set_double_val(double value);

  // .ChakraProtoMsg.DoubleList double_list = 4;
  bool has_double_list() const;
  void clear_double_list();
  static const int kDoubleListFieldNumber = 4;
  private:
  const ::ChakraProtoMsg::DoubleList& _internal_double_list() const;
  public:
  const ::ChakraProtoMsg::DoubleList& double_list() const;
  ::ChakraProtoMsg::DoubleList* release_double_list();
  ::ChakraProtoMsg::DoubleList* mutable_double_list();
  void set_allocated_double_list(::ChakraProtoMsg::DoubleList* double_list);

  // float float_val = 5;
  private:
  bool has_float_val() const;
  public:
  void clear_float_val();
  static const int kFloatValFieldNumber = 5;
  float float_val() const;
  void set_float_val(float value);

  // .ChakraProtoMsg.FloatList float_list = 6;
  bool has_float_list() const;
  void clear_float_list();
  static const int kFloatListFieldNumber = 6;
  private:
  const ::ChakraProtoMsg::FloatList& _internal_float_list() const;
  public:
  const ::ChakraProtoMsg::FloatList& float_list() const;
  ::ChakraProtoMsg::FloatList* release_float_list();
  ::ChakraProtoMsg::FloatList* mutable_float_list();
  void set_allocated_float_list(::ChakraProtoMsg::FloatList* float_list);

  // int32 int32_val = 7;
  private:
  bool has_int32_val() const;
  public:
  void clear_int32_val();
  static const int kInt32ValFieldNumber = 7;
  ::google::protobuf::int32 int32_val() const;
  void set_int32_val(::google::protobuf::int32 value);

  // .ChakraProtoMsg.Int32List int32_list = 8;
  bool has_int32_list() const;
  void clear_int32_list();
  static const int kInt32ListFieldNumber = 8;
  private:
  const ::ChakraProtoMsg::Int32List& _internal_int32_list() const;
  public:
  const ::ChakraProtoMsg::Int32List& int32_list() const;
  ::ChakraProtoMsg::Int32List* release_int32_list();
  ::ChakraProtoMsg::Int32List* mutable_int32_list();
  void set_allocated_int32_list(::ChakraProtoMsg::Int32List* int32_list);

  // int64 int64_val = 9;
  private:
  bool has_int64_val() const;
  public:
  void clear_int64_val();
  static const int kInt64ValFieldNumber = 9;
  ::google::protobuf::int64 int64_val() const;
  void set_int64_val(::google::protobuf::int64 value);

  // .ChakraProtoMsg.Int64List int64_list = 10;
  bool has_int64_list() const;
  void clear_int64_list();
  static const int kInt64ListFieldNumber = 10;
  private:
  const ::ChakraProtoMsg::Int64List& _internal_int64_list() const;
  public:
  const ::ChakraProtoMsg::Int64List& int64_list() const;
  ::ChakraProtoMsg::Int64List* release_int64_list();
  ::ChakraProtoMsg::Int64List* mutable_int64_list();
  void set_allocated_int64_list(::ChakraProtoMsg::Int64List* int64_list);

  // uint32 uint32_val = 11;
  private:
  bool has_uint32_val() const;
  public:
  void clear_uint32_val();
  static const int kUint32ValFieldNumber = 11;
  ::google::protobuf::uint32 uint32_val() const;
  void set_uint32_val(::google::protobuf::uint32 value);

  // .ChakraProtoMsg.Uint32List uint32_list = 12;
  bool has_uint32_list() const;
  void clear_uint32_list();
  static const int kUint32ListFieldNumber = 12;
  private:
  const ::ChakraProtoMsg::Uint32List& _internal_uint32_list() const;
  public:
  const ::ChakraProtoMsg::Uint32List& uint32_list() const;
  ::ChakraProtoMsg::Uint32List* release_uint32_list();
  ::ChakraProtoMsg::Uint32List* mutable_uint32_list();
  void set_allocated_uint32_list(::ChakraProtoMsg::Uint32List* uint32_list);

  // uint64 uint64_val = 13;
  private:
  bool has_uint64_val() const;
  public:
  void clear_uint64_val();
  static const int kUint64ValFieldNumber = 13;
  ::google::protobuf::uint64 uint64_val() const;
  void set_uint64_val(::google::protobuf::uint64 value);

  // .ChakraProtoMsg.Uint64List uint64_list = 14;
  bool has_uint64_list() const;
  void clear_uint64_list();
  static const int kUint64ListFieldNumber = 14;
  private:
  const ::ChakraProtoMsg::Uint64List& _internal_uint64_list() const;
  public:
  const ::ChakraProtoMsg::Uint64List& uint64_list() const;
  ::ChakraProtoMsg::Uint64List* release_uint64_list();
  ::ChakraProtoMsg::Uint64List* mutable_uint64_list();
  void set_allocated_uint64_list(::ChakraProtoMsg::Uint64List* uint64_list);

  // sint32 sint32_val = 15;
  private:
  bool has_sint32_val() const;
  public:
  void clear_sint32_val();
  static const int kSint32ValFieldNumber = 15;
  ::google::protobuf::int32 sint32_val() const;
  void set_sint32_val(::google::protobuf::int32 value);

  // .ChakraProtoMsg.Sint32List sint32_list = 16;
  bool has_sint32_list() const;
  void clear_sint32_list();
  static const int kSint32ListFieldNumber = 16;
  private:
  const ::ChakraProtoMsg::Sint32List& _internal_sint32_list() const;
  public:
  const ::ChakraProtoMsg::Sint32List& sint32_list() const;
  ::ChakraProtoMsg::Sint32List* release_sint32_list();
  ::ChakraProtoMsg::Sint32List* mutable_sint32_list();
  void set_allocated_sint32_list(::ChakraProtoMsg::Sint32List* sint32_list);

  // sint64 sint64_val = 17;
  private:
  bool has_sint64_val() const;
  public:
  void clear_sint64_val();
  static const int kSint64ValFieldNumber = 17;
  ::google::protobuf::int64 sint64_val() const;
  void set_sint64_val(::google::protobuf::int64 value);

  // .ChakraProtoMsg.Sint64List sint64_list = 18;
  bool has_sint64_list() const;
  void clear_sint64_list();
  static const int kSint64ListFieldNumber = 18;
  private:
  const ::ChakraProtoMsg::Sint64List& _internal_sint64_list() const;
  public:
  const ::ChakraProtoMsg::Sint64List& sint64_list() const;
  ::ChakraProtoMsg::Sint64List* release_sint64_list();
  ::ChakraProtoMsg::Sint64List* mutable_sint64_list();
  void set_allocated_sint64_list(::ChakraProtoMsg::Sint64List* sint64_list);

  // fixed32 fixed32_val = 19;
  private:
  bool has_fixed32_val() const;
  public:
  void clear_fixed32_val();
  static const int kFixed32ValFieldNumber = 19;
  ::google::protobuf::uint32 fixed32_val() const;
  void set_fixed32_val(::google::protobuf::uint32 value);

  // .ChakraProtoMsg.Fixed32List fixed32_list = 20;
  bool has_fixed32_list() const;
  void clear_fixed32_list();
  static const int kFixed32ListFieldNumber = 20;
  private:
  const ::ChakraProtoMsg::Fixed32List& _internal_fixed32_list() const;
  public:
  const ::ChakraProtoMsg::Fixed32List& fixed32_list() const;
  ::ChakraProtoMsg::Fixed32List* release_fixed32_list();
  ::ChakraProtoMsg::Fixed32List* mutable_fixed32_list();
  void set_allocated_fixed32_list(::ChakraProtoMsg::Fixed32List* fixed32_list);

  // fixed64 fixed64_val = 21;
  private:
  bool has_fixed64_val() const;
  public:
  void clear_fixed64_val();
  static const int kFixed64ValFieldNumber = 21;
  ::google::protobuf::uint64 fixed64_val() const;
  void set_fixed64_val(::google::protobuf::uint64 value);

  // .ChakraProtoMsg.Fixed64List fixed64_list = 22;
  bool has_fixed64_list() const;
  void clear_fixed64_list();
  static const int kFixed64ListFieldNumber = 22;
  private:
  const ::ChakraProtoMsg::Fixed64List& _internal_fixed64_list() const;
  public:
  const ::ChakraProtoMsg::Fixed64List& fixed64_list() const;
  ::ChakraProtoMsg::Fixed64List* release_fixed64_list();
  ::ChakraProtoMsg::Fixed64List* mutable_fixed64_list();
  void set_allocated_fixed64_list(::ChakraProtoMsg::Fixed64List* fixed64_list);

  // sfixed32 sfixed32_val = 23;
  private:
  bool has_sfixed32_val() const;
  public:
  void clear_sfixed32_val();
  static const int kSfixed32ValFieldNumber = 23;
  ::google::protobuf::int32 sfixed32_val() const;
  void set_sfixed32_val(::google::protobuf::int32 value);

  // .ChakraProtoMsg.Sfixed32List sfixed32_list = 24;
  bool has_sfixed32_list() const;
  void clear_sfixed32_list();
  static const int kSfixed32ListFieldNumber = 24;
  private:
  const ::ChakraProtoMsg::Sfixed32List& _internal_sfixed32_list() const;
  public:
  const ::ChakraProtoMsg::Sfixed32List& sfixed32_list() const;
  ::ChakraProtoMsg::Sfixed32List* release_sfixed32_list();
  ::ChakraProtoMsg::Sfixed32List* mutable_sfixed32_list();
  void set_allocated_sfixed32_list(::ChakraProtoMsg::Sfixed32List* sfixed32_list);

  // sfixed64 sfixed64_val = 25;
  private:
  bool has_sfixed64_val() const;
  public:
  void clear_sfixed64_val();
  static const int kSfixed64ValFieldNumber = 25;
  ::google::protobuf::int64 sfixed64_val() const;
  void set_sfixed64_val(::google::protobuf::int64 value);

  // .ChakraProtoMsg.Sfixed64List sfixed64_list = 26;
  bool has_sfixed64_list() const;
  void clear_sfixed64_list();
  static const int kSfixed64ListFieldNumber = 26;
  private:
  const ::ChakraProtoMsg::Sfixed64List& _internal_sfixed64_list() const;
  public:
  const ::ChakraProtoMsg::Sfixed64List& sfixed64_list() const;
  ::ChakraProtoMsg::Sfixed64List* release_sfixed64_list();
  ::ChakraProtoMsg::Sfixed64List* mutable_sfixed64_list();
  void set_allocated_sfixed64_list(::ChakraProtoMsg::Sfixed64List* sfixed64_list);

  // bool bool_val = 27;
  private:
  bool has_bool_val() const;
  public:
  void clear_bool_val();
  static const int kBoolValFieldNumber = 27;
  bool bool_val() const;
  void set_bool_val(bool value);

  // .ChakraProtoMsg.BoolList bool_list = 28;
  bool has_bool_list() const;
  void clear_bool_list();
  static const int kBoolListFieldNumber = 28;
  private:
  const ::ChakraProtoMsg::BoolList& _internal_bool_list() const;
  public:
  const ::ChakraProtoMsg::BoolList& bool_list() const;
  ::ChakraProtoMsg::BoolList* release_bool_list();
  ::ChakraProtoMsg::BoolList* mutable_bool_list();
  void set_allocated_bool_list(::ChakraProtoMsg::BoolList* bool_list);

  // string string_val = 29;
  private:
  bool has_string_val() const;
  public:
  void clear_string_val();
  static const int kStringValFieldNumber = 29;
  const ::std::string& string_val() const;
  void set_string_val(const ::std::string& value);
  #if LANG_CXX11
  void set_string_val(::std::string&& value);
  #endif
  void set_string_val(const char* value);
  void set_string_val(const char* value, size_t size);
  ::std::string* mutable_string_val();
  ::std::string* release_string_val();
  void set_allocated_string_val(::std::string* string_val);

  // .ChakraProtoMsg.StringList string_list = 30;
  bool has_string_list() const;
  void clear_string_list();
  static const int kStringListFieldNumber = 30;
  private:
  const ::ChakraProtoMsg::StringList& _internal_string_list() const;
  public:
  const ::ChakraProtoMsg::StringList& string_list() const;
  ::ChakraProtoMsg::StringList* release_string_list();
  ::ChakraProtoMsg::StringList* mutable_string_list();
  void set_allocated_string_list(::ChakraProtoMsg::StringList* string_list);

  // bytes bytes_val = 31;
  private:
  bool has_bytes_val() const;
  public:
  void clear_bytes_val();
  static const int kBytesValFieldNumber = 31;
  const ::std::string& bytes_val() const;
  void set_bytes_val(const ::std::string& value);
  #if LANG_CXX11
  void set_bytes_val(::std::string&& value);
  #endif
  void set_bytes_val(const char* value);
  void set_bytes_val(const void* value, size_t size);
  ::std::string* mutable_bytes_val();
  ::std::string* release_bytes_val();
  void set_allocated_bytes_val(::std::string* bytes_val);

  // .ChakraProtoMsg.BytesList bytes_list = 32;
  bool has_bytes_list() const;
  void clear_bytes_list();
  static const int kBytesListFieldNumber = 32;
  private:
  const ::ChakraProtoMsg::BytesList& _internal_bytes_list() const;
  public:
  const ::ChakraProtoMsg::BytesList& bytes_list() const;
  ::ChakraProtoMsg::BytesList* release_bytes_list();
  ::ChakraProtoMsg::BytesList* mutable_bytes_list();
  void set_allocated_bytes_list(::ChakraProtoMsg::BytesList* bytes_list);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.AttributeProto)
 private:
  void set_has_double_val();
  void set_has_double_list();
  void set_has_float_val();
  void set_has_float_list();
  void set_has_int32_val();
  void set_has_int32_list();
  void set_has_int64_val();
  void set_has_int64_list();
  void set_has_uint32_val();
  void set_has_uint32_list();
  void set_has_uint64_val();
  void set_has_uint64_list();
  void set_has_sint32_val();
  void set_has_sint32_list();
  void set_has_sint64_val();
  void set_has_sint64_list();
  void set_has_fixed32_val();
  void set_has_fixed32_list();
  void set_has_fixed64_val();
  void set_has_fixed64_list();
  void set_has_sfixed32_val();
  void set_has_sfixed32_list();
  void set_has_sfixed64_val();
  void set_has_sfixed64_list();
  void set_has_bool_val();
  void set_has_bool_list();
  void set_has_string_val();
  void set_has_string_list();
  void set_has_bytes_val();
  void set_has_bytes_list();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr doc_string_;
  union ValueUnion {
    ValueUnion() {}
    double double_val_;
    ::ChakraProtoMsg::DoubleList* double_list_;
    float float_val_;
    ::ChakraProtoMsg::FloatList* float_list_;
    ::google::protobuf::int32 int32_val_;
    ::ChakraProtoMsg::Int32List* int32_list_;
    ::google::protobuf::int64 int64_val_;
    ::ChakraProtoMsg::Int64List* int64_list_;
    ::google::protobuf::uint32 uint32_val_;
    ::ChakraProtoMsg::Uint32List* uint32_list_;
    ::google::protobuf::uint64 uint64_val_;
    ::ChakraProtoMsg::Uint64List* uint64_list_;
    ::google::protobuf::int32 sint32_val_;
    ::ChakraProtoMsg::Sint32List* sint32_list_;
    ::google::protobuf::int64 sint64_val_;
    ::ChakraProtoMsg::Sint64List* sint64_list_;
    ::google::protobuf::uint32 fixed32_val_;
    ::ChakraProtoMsg::Fixed32List* fixed32_list_;
    ::google::protobuf::uint64 fixed64_val_;
    ::ChakraProtoMsg::Fixed64List* fixed64_list_;
    ::google::protobuf::int32 sfixed32_val_;
    ::ChakraProtoMsg::Sfixed32List* sfixed32_list_;
    ::google::protobuf::int64 sfixed64_val_;
    ::ChakraProtoMsg::Sfixed64List* sfixed64_list_;
    bool bool_val_;
    ::ChakraProtoMsg::BoolList* bool_list_;
    ::google::protobuf::internal::ArenaStringPtr string_val_;
    ::ChakraProtoMsg::StringList* string_list_;
    ::google::protobuf::internal::ArenaStringPtr bytes_val_;
    ::ChakraProtoMsg::BytesList* bytes_list_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoubleList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.DoubleList) */ {
 public:
  DoubleList();
  virtual ~DoubleList();

  DoubleList(const DoubleList& from);

  inline DoubleList& operator=(const DoubleList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleList(DoubleList&& from) noexcept
    : DoubleList() {
    *this = ::std::move(from);
  }

  inline DoubleList& operator=(DoubleList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleList* internal_default_instance() {
    return reinterpret_cast<const DoubleList*>(
               &_DoubleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DoubleList* other);
  friend void swap(DoubleList& a, DoubleList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleList* New() const final {
    return CreateMaybeMessage<DoubleList>(NULL);
  }

  DoubleList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoubleList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoubleList& from);
  void MergeFrom(const DoubleList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField< double >&
      values() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.DoubleList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FloatList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.FloatList) */ {
 public:
  FloatList();
  virtual ~FloatList();

  FloatList(const FloatList& from);

  inline FloatList& operator=(const FloatList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatList(FloatList&& from) noexcept
    : FloatList() {
    *this = ::std::move(from);
  }

  inline FloatList& operator=(FloatList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatList* internal_default_instance() {
    return reinterpret_cast<const FloatList*>(
               &_FloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FloatList* other);
  friend void swap(FloatList& a, FloatList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatList* New() const final {
    return CreateMaybeMessage<FloatList>(NULL);
  }

  FloatList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatList& from);
  void MergeFrom(const FloatList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField< float >&
      values() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.FloatList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Int32List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Int32List) */ {
 public:
  Int32List();
  virtual ~Int32List();

  Int32List(const Int32List& from);

  inline Int32List& operator=(const Int32List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int32List(Int32List&& from) noexcept
    : Int32List() {
    *this = ::std::move(from);
  }

  inline Int32List& operator=(Int32List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Int32List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int32List* internal_default_instance() {
    return reinterpret_cast<const Int32List*>(
               &_Int32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Int32List* other);
  friend void swap(Int32List& a, Int32List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int32List* New() const final {
    return CreateMaybeMessage<Int32List>(NULL);
  }

  Int32List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int32List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int32List& from);
  void MergeFrom(const Int32List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int32 values(int index) const;
  void set_values(int index, ::google::protobuf::int32 value);
  void add_values(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Int32List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Int64List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Int64List) */ {
 public:
  Int64List();
  virtual ~Int64List();

  Int64List(const Int64List& from);

  inline Int64List& operator=(const Int64List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int64List(Int64List&& from) noexcept
    : Int64List() {
    *this = ::std::move(from);
  }

  inline Int64List& operator=(Int64List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Int64List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int64List* internal_default_instance() {
    return reinterpret_cast<const Int64List*>(
               &_Int64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Int64List* other);
  friend void swap(Int64List& a, Int64List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int64List* New() const final {
    return CreateMaybeMessage<Int64List>(NULL);
  }

  Int64List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int64List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int64List& from);
  void MergeFrom(const Int64List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int64 values(int index) const;
  void set_values(int index, ::google::protobuf::int64 value);
  void add_values(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Int64List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Uint32List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Uint32List) */ {
 public:
  Uint32List();
  virtual ~Uint32List();

  Uint32List(const Uint32List& from);

  inline Uint32List& operator=(const Uint32List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Uint32List(Uint32List&& from) noexcept
    : Uint32List() {
    *this = ::std::move(from);
  }

  inline Uint32List& operator=(Uint32List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Uint32List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Uint32List* internal_default_instance() {
    return reinterpret_cast<const Uint32List*>(
               &_Uint32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Uint32List* other);
  friend void swap(Uint32List& a, Uint32List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Uint32List* New() const final {
    return CreateMaybeMessage<Uint32List>(NULL);
  }

  Uint32List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Uint32List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Uint32List& from);
  void MergeFrom(const Uint32List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint32List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::uint32 values(int index) const;
  void set_values(int index, ::google::protobuf::uint32 value);
  void add_values(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Uint32List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Uint64List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Uint64List) */ {
 public:
  Uint64List();
  virtual ~Uint64List();

  Uint64List(const Uint64List& from);

  inline Uint64List& operator=(const Uint64List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Uint64List(Uint64List&& from) noexcept
    : Uint64List() {
    *this = ::std::move(from);
  }

  inline Uint64List& operator=(Uint64List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Uint64List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Uint64List* internal_default_instance() {
    return reinterpret_cast<const Uint64List*>(
               &_Uint64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Uint64List* other);
  friend void swap(Uint64List& a, Uint64List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Uint64List* New() const final {
    return CreateMaybeMessage<Uint64List>(NULL);
  }

  Uint64List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Uint64List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Uint64List& from);
  void MergeFrom(const Uint64List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint64List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::uint64 values(int index) const;
  void set_values(int index, ::google::protobuf::uint64 value);
  void add_values(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Uint64List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sint32List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sint32List) */ {
 public:
  Sint32List();
  virtual ~Sint32List();

  Sint32List(const Sint32List& from);

  inline Sint32List& operator=(const Sint32List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sint32List(Sint32List&& from) noexcept
    : Sint32List() {
    *this = ::std::move(from);
  }

  inline Sint32List& operator=(Sint32List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sint32List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sint32List* internal_default_instance() {
    return reinterpret_cast<const Sint32List*>(
               &_Sint32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Sint32List* other);
  friend void swap(Sint32List& a, Sint32List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sint32List* New() const final {
    return CreateMaybeMessage<Sint32List>(NULL);
  }

  Sint32List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sint32List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sint32List& from);
  void MergeFrom(const Sint32List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sint32List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint32 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int32 values(int index) const;
  void set_values(int index, ::google::protobuf::int32 value);
  void add_values(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sint32List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sint64List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sint64List) */ {
 public:
  Sint64List();
  virtual ~Sint64List();

  Sint64List(const Sint64List& from);

  inline Sint64List& operator=(const Sint64List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sint64List(Sint64List&& from) noexcept
    : Sint64List() {
    *this = ::std::move(from);
  }

  inline Sint64List& operator=(Sint64List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sint64List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sint64List* internal_default_instance() {
    return reinterpret_cast<const Sint64List*>(
               &_Sint64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Sint64List* other);
  friend void swap(Sint64List& a, Sint64List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sint64List* New() const final {
    return CreateMaybeMessage<Sint64List>(NULL);
  }

  Sint64List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sint64List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sint64List& from);
  void MergeFrom(const Sint64List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sint64List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint64 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int64 values(int index) const;
  void set_values(int index, ::google::protobuf::int64 value);
  void add_values(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sint64List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Fixed32List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Fixed32List) */ {
 public:
  Fixed32List();
  virtual ~Fixed32List();

  Fixed32List(const Fixed32List& from);

  inline Fixed32List& operator=(const Fixed32List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fixed32List(Fixed32List&& from) noexcept
    : Fixed32List() {
    *this = ::std::move(from);
  }

  inline Fixed32List& operator=(Fixed32List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Fixed32List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fixed32List* internal_default_instance() {
    return reinterpret_cast<const Fixed32List*>(
               &_Fixed32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Fixed32List* other);
  friend void swap(Fixed32List& a, Fixed32List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fixed32List* New() const final {
    return CreateMaybeMessage<Fixed32List>(NULL);
  }

  Fixed32List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Fixed32List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Fixed32List& from);
  void MergeFrom(const Fixed32List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fixed32List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed32 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::uint32 values(int index) const;
  void set_values(int index, ::google::protobuf::uint32 value);
  void add_values(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Fixed32List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Fixed64List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Fixed64List) */ {
 public:
  Fixed64List();
  virtual ~Fixed64List();

  Fixed64List(const Fixed64List& from);

  inline Fixed64List& operator=(const Fixed64List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fixed64List(Fixed64List&& from) noexcept
    : Fixed64List() {
    *this = ::std::move(from);
  }

  inline Fixed64List& operator=(Fixed64List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Fixed64List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fixed64List* internal_default_instance() {
    return reinterpret_cast<const Fixed64List*>(
               &_Fixed64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Fixed64List* other);
  friend void swap(Fixed64List& a, Fixed64List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fixed64List* New() const final {
    return CreateMaybeMessage<Fixed64List>(NULL);
  }

  Fixed64List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Fixed64List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Fixed64List& from);
  void MergeFrom(const Fixed64List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fixed64List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed64 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::uint64 values(int index) const;
  void set_values(int index, ::google::protobuf::uint64 value);
  void add_values(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Fixed64List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sfixed32List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sfixed32List) */ {
 public:
  Sfixed32List();
  virtual ~Sfixed32List();

  Sfixed32List(const Sfixed32List& from);

  inline Sfixed32List& operator=(const Sfixed32List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sfixed32List(Sfixed32List&& from) noexcept
    : Sfixed32List() {
    *this = ::std::move(from);
  }

  inline Sfixed32List& operator=(Sfixed32List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sfixed32List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sfixed32List* internal_default_instance() {
    return reinterpret_cast<const Sfixed32List*>(
               &_Sfixed32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Sfixed32List* other);
  friend void swap(Sfixed32List& a, Sfixed32List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sfixed32List* New() const final {
    return CreateMaybeMessage<Sfixed32List>(NULL);
  }

  Sfixed32List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sfixed32List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sfixed32List& from);
  void MergeFrom(const Sfixed32List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sfixed32List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sfixed32 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int32 values(int index) const;
  void set_values(int index, ::google::protobuf::int32 value);
  void add_values(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sfixed32List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sfixed64List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sfixed64List) */ {
 public:
  Sfixed64List();
  virtual ~Sfixed64List();

  Sfixed64List(const Sfixed64List& from);

  inline Sfixed64List& operator=(const Sfixed64List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sfixed64List(Sfixed64List&& from) noexcept
    : Sfixed64List() {
    *this = ::std::move(from);
  }

  inline Sfixed64List& operator=(Sfixed64List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sfixed64List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sfixed64List* internal_default_instance() {
    return reinterpret_cast<const Sfixed64List*>(
               &_Sfixed64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Sfixed64List* other);
  friend void swap(Sfixed64List& a, Sfixed64List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sfixed64List* New() const final {
    return CreateMaybeMessage<Sfixed64List>(NULL);
  }

  Sfixed64List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sfixed64List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sfixed64List& from);
  void MergeFrom(const Sfixed64List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sfixed64List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sfixed64 values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::google::protobuf::int64 values(int index) const;
  void set_values(int index, ::google::protobuf::int64 value);
  void add_values(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      values() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sfixed64List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoolList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.BoolList) */ {
 public:
  BoolList();
  virtual ~BoolList();

  BoolList(const BoolList& from);

  inline BoolList& operator=(const BoolList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoolList(BoolList&& from) noexcept
    : BoolList() {
    *this = ::std::move(from);
  }

  inline BoolList& operator=(BoolList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoolList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoolList* internal_default_instance() {
    return reinterpret_cast<const BoolList*>(
               &_BoolList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(BoolList* other);
  friend void swap(BoolList& a, BoolList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoolList* New() const final {
    return CreateMaybeMessage<BoolList>(NULL);
  }

  BoolList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BoolList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BoolList& from);
  void MergeFrom(const BoolList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      values() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.BoolList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< bool > values_;
  mutable int _values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.StringList) */ {
 public:
  StringList();
  virtual ~StringList();

  StringList(const StringList& from);

  inline StringList& operator=(const StringList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringList(StringList&& from) noexcept
    : StringList() {
    *this = ::std::move(from);
  }

  inline StringList& operator=(StringList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringList* internal_default_instance() {
    return reinterpret_cast<const StringList*>(
               &_StringList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(StringList* other);
  friend void swap(StringList& a, StringList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringList* New() const final {
    return CreateMaybeMessage<StringList>(NULL);
  }

  StringList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringList& from);
  void MergeFrom(const StringList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.StringList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytesList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.BytesList) */ {
 public:
  BytesList();
  virtual ~BytesList();

  BytesList(const BytesList& from);

  inline BytesList& operator=(const BytesList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytesList(BytesList&& from) noexcept
    : BytesList() {
    *this = ::std::move(from);
  }

  inline BytesList& operator=(BytesList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BytesList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytesList* internal_default_instance() {
    return reinterpret_cast<const BytesList*>(
               &_BytesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(BytesList* other);
  friend void swap(BytesList& a, BytesList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytesList* New() const final {
    return CreateMaybeMessage<BytesList>(NULL);
  }

  BytesList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytesList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytesList& from);
  void MergeFrom(const BytesList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytesList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.BytesList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GlobalMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.GlobalMetadata) */ {
 public:
  GlobalMetadata();
  virtual ~GlobalMetadata();

  GlobalMetadata(const GlobalMetadata& from);

  inline GlobalMetadata& operator=(const GlobalMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GlobalMetadata(GlobalMetadata&& from) noexcept
    : GlobalMetadata() {
    *this = ::std::move(from);
  }

  inline GlobalMetadata& operator=(GlobalMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlobalMetadata* internal_default_instance() {
    return reinterpret_cast<const GlobalMetadata*>(
               &_GlobalMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GlobalMetadata* other);
  friend void swap(GlobalMetadata& a, GlobalMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GlobalMetadata* New() const final {
    return CreateMaybeMessage<GlobalMetadata>(NULL);
  }

  GlobalMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GlobalMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GlobalMetadata& from);
  void MergeFrom(const GlobalMetadata& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ChakraProtoMsg.AttributeProto attr = 2;
  int attr_size() const;
  void clear_attr();
  static const int kAttrFieldNumber = 2;
  ::ChakraProtoMsg::AttributeProto* mutable_attr(int index);
  ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
      mutable_attr();
  const ::ChakraProtoMsg::AttributeProto& attr(int index) const;
  ::ChakraProtoMsg::AttributeProto* add_attr();
  const ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
      attr() const;

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.GlobalMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto > attr_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(NULL);
  }

  Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 ctrl_deps = 4;
  int ctrl_deps_size() const;
  void clear_ctrl_deps();
  static const int kCtrlDepsFieldNumber = 4;
  ::google::protobuf::uint64 ctrl_deps(int index) const;
  void set_ctrl_deps(int index, ::google::protobuf::uint64 value);
  void add_ctrl_deps(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      ctrl_deps() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_ctrl_deps();

  // repeated uint64 data_deps = 5;
  int data_deps_size() const;
  void clear_data_deps();
  static const int kDataDepsFieldNumber = 5;
  ::google::protobuf::uint64 data_deps(int index) const;
  void set_data_deps(int index, ::google::protobuf::uint64 value);
  void add_data_deps(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      data_deps() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_data_deps();

  // repeated .ChakraProtoMsg.AttributeProto attr = 10;
  int attr_size() const;
  void clear_attr();
  static const int kAttrFieldNumber = 10;
  ::ChakraProtoMsg::AttributeProto* mutable_attr(int index);
  ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
      mutable_attr();
  const ::ChakraProtoMsg::AttributeProto& attr(int index) const;
  ::ChakraProtoMsg::AttributeProto* add_attr();
  const ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
      attr() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .ChakraProtoMsg.IOInfo inputs = 8;
  bool has_inputs() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 8;
  private:
  const ::ChakraProtoMsg::IOInfo& _internal_inputs() const;
  public:
  const ::ChakraProtoMsg::IOInfo& inputs() const;
  ::ChakraProtoMsg::IOInfo* release_inputs();
  ::ChakraProtoMsg::IOInfo* mutable_inputs();
  void set_allocated_inputs(::ChakraProtoMsg::IOInfo* inputs);

  // .ChakraProtoMsg.IOInfo outputs = 9;
  bool has_outputs() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 9;
  private:
  const ::ChakraProtoMsg::IOInfo& _internal_outputs() const;
  public:
  const ::ChakraProtoMsg::IOInfo& outputs() const;
  ::ChakraProtoMsg::IOInfo* release_outputs();
  ::ChakraProtoMsg::IOInfo* mutable_outputs();
  void set_allocated_outputs(::ChakraProtoMsg::IOInfo* outputs);

  // uint64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // uint64 start_time_micros = 6;
  void clear_start_time_micros();
  static const int kStartTimeMicrosFieldNumber = 6;
  ::google::protobuf::uint64 start_time_micros() const;
  void set_start_time_micros(::google::protobuf::uint64 value);

  // uint64 duration_micros = 7;
  void clear_duration_micros();
  static const int kDurationMicrosFieldNumber = 7;
  ::google::protobuf::uint64 duration_micros() const;
  void set_duration_micros(::google::protobuf::uint64 value);

  // .ChakraProtoMsg.NodeType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::ChakraProtoMsg::NodeType type() const;
  void set_type(::ChakraProtoMsg::NodeType value);

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > ctrl_deps_;
  mutable int _ctrl_deps_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > data_deps_;
  mutable int _data_deps_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto > attr_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::ChakraProtoMsg::IOInfo* inputs_;
  ::ChakraProtoMsg::IOInfo* outputs_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 start_time_micros_;
  ::google::protobuf::uint64 duration_micros_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IOInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.IOInfo) */ {
 public:
  IOInfo();
  virtual ~IOInfo();

  IOInfo(const IOInfo& from);

  inline IOInfo& operator=(const IOInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IOInfo(IOInfo&& from) noexcept
    : IOInfo() {
    *this = ::std::move(from);
  }

  inline IOInfo& operator=(IOInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IOInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IOInfo* internal_default_instance() {
    return reinterpret_cast<const IOInfo*>(
               &_IOInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(IOInfo* other);
  friend void swap(IOInfo& a, IOInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IOInfo* New() const final {
    return CreateMaybeMessage<IOInfo>(NULL);
  }

  IOInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IOInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IOInfo& from);
  void MergeFrom(const IOInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string values = 1;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::std::string& values() const;
  void set_values(const ::std::string& value);
  #if LANG_CXX11
  void set_values(::std::string&& value);
  #endif
  void set_values(const char* value);
  void set_values(const char* value, size_t size);
  ::std::string* mutable_values();
  ::std::string* release_values();
  void set_allocated_values(::std::string* values);

  // string shapes = 2;
  void clear_shapes();
  static const int kShapesFieldNumber = 2;
  const ::std::string& shapes() const;
  void set_shapes(const ::std::string& value);
  #if LANG_CXX11
  void set_shapes(::std::string&& value);
  #endif
  void set_shapes(const char* value);
  void set_shapes(const char* value, size_t size);
  ::std::string* mutable_shapes();
  ::std::string* release_shapes();
  void set_allocated_shapes(::std::string* shapes);

  // string types = 3;
  void clear_types();
  static const int kTypesFieldNumber = 3;
  const ::std::string& types() const;
  void set_types(const ::std::string& value);
  #if LANG_CXX11
  void set_types(::std::string&& value);
  #endif
  void set_types(const char* value);
  void set_types(const char* value, size_t size);
  ::std::string* mutable_types();
  ::std::string* release_types();
  void set_allocated_types(::std::string* types);

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.IOInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr values_;
  ::google::protobuf::internal::ArenaStringPtr shapes_;
  ::google::protobuf::internal::ArenaStringPtr types_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Tensor) */ {
 public:
  Tensor();
  virtual ~Tensor();

  Tensor(const Tensor& from);

  inline Tensor& operator=(const Tensor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tensor(Tensor&& from) noexcept
    : Tensor() {
    *this = ::std::move(from);
  }

  inline Tensor& operator=(Tensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tensor* internal_default_instance() {
    return reinterpret_cast<const Tensor*>(
               &_Tensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Tensor* other);
  friend void swap(Tensor& a, Tensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tensor* New() const final {
    return CreateMaybeMessage<Tensor>(NULL);
  }

  Tensor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tensor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tensor& from);
  void MergeFrom(const Tensor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device = 6;
  void clear_device();
  static const int kDeviceFieldNumber = 6;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // uint64 tensor_id = 1;
  void clear_tensor_id();
  static const int kTensorIdFieldNumber = 1;
  ::google::protobuf::uint64 tensor_id() const;
  void set_tensor_id(::google::protobuf::uint64 value);

  // uint64 storage_id = 2;
  void clear_storage_id();
  static const int kStorageIdFieldNumber = 2;
  ::google::protobuf::uint64 storage_id() const;
  void set_storage_id(::google::protobuf::uint64 value);

  // uint64 offset = 3;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // uint64 num_elem = 4;
  void clear_num_elem();
  static const int kNumElemFieldNumber = 4;
  ::google::protobuf::uint64 num_elem() const;
  void set_num_elem(::google::protobuf::uint64 value);

  // uint64 elem_bytes = 5;
  void clear_elem_bytes();
  static const int kElemBytesFieldNumber = 5;
  ::google::protobuf::uint64 elem_bytes() const;
  void set_elem_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Tensor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::uint64 tensor_id_;
  ::google::protobuf::uint64 storage_id_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 num_elem_;
  ::google::protobuf::uint64 elem_bytes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_et_5fdef_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AttributeProto

// string name = 1;
inline void AttributeProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AttributeProto::name() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.name)
  return name_.GetNoArena();
}
inline void AttributeProto::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.name)
}
#if LANG_CXX11
inline void AttributeProto::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.AttributeProto.name)
}
#endif
inline void AttributeProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.AttributeProto.name)
}
inline void AttributeProto::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.AttributeProto.name)
}
inline ::std::string* AttributeProto::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttributeProto::release_name() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttributeProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.name)
}

// string doc_string = 2;
inline void AttributeProto::clear_doc_string() {
  doc_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AttributeProto::doc_string() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.doc_string)
  return doc_string_.GetNoArena();
}
inline void AttributeProto::set_doc_string(const ::std::string& value) {
  
  doc_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.doc_string)
}
#if LANG_CXX11
inline void AttributeProto::set_doc_string(::std::string&& value) {
  
  doc_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.AttributeProto.doc_string)
}
#endif
inline void AttributeProto::set_doc_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  doc_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.AttributeProto.doc_string)
}
inline void AttributeProto::set_doc_string(const char* value, size_t size) {
  
  doc_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.AttributeProto.doc_string)
}
inline ::std::string* AttributeProto::mutable_doc_string() {
  
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.doc_string)
  return doc_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttributeProto::release_doc_string() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.doc_string)
  
  return doc_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttributeProto::set_allocated_doc_string(::std::string* doc_string) {
  if (doc_string != NULL) {
    
  } else {
    
  }
  doc_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), doc_string);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.doc_string)
}

// double double_val = 3;
inline bool AttributeProto::has_double_val() const {
  return value_case() == kDoubleVal;
}
inline void AttributeProto::set_has_double_val() {
  _oneof_case_[0] = kDoubleVal;
}
inline void AttributeProto::clear_double_val() {
  if (has_double_val()) {
    value_.double_val_ = 0;
    clear_has_value();
  }
}
inline double AttributeProto::double_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.double_val)
  if (has_double_val()) {
    return value_.double_val_;
  }
  return 0;
}
inline void AttributeProto::set_double_val(double value) {
  if (!has_double_val()) {
    clear_value();
    set_has_double_val();
  }
  value_.double_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.double_val)
}

// .ChakraProtoMsg.DoubleList double_list = 4;
inline bool AttributeProto::has_double_list() const {
  return value_case() == kDoubleList;
}
inline void AttributeProto::set_has_double_list() {
  _oneof_case_[0] = kDoubleList;
}
inline void AttributeProto::clear_double_list() {
  if (has_double_list()) {
    delete value_.double_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::DoubleList& AttributeProto::_internal_double_list() const {
  return *value_.double_list_;
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::release_double_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.double_list)
  if (has_double_list()) {
    clear_has_value();
      ::ChakraProtoMsg::DoubleList* temp = value_.double_list_;
    value_.double_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::DoubleList& AttributeProto::double_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.double_list)
  return has_double_list()
      ? *value_.double_list_
      : *reinterpret_cast< ::ChakraProtoMsg::DoubleList*>(&::ChakraProtoMsg::_DoubleList_default_instance_);
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::mutable_double_list() {
  if (!has_double_list()) {
    clear_value();
    set_has_double_list();
    value_.double_list_ = CreateMaybeMessage< ::ChakraProtoMsg::DoubleList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.double_list)
  return value_.double_list_;
}

// float float_val = 5;
inline bool AttributeProto::has_float_val() const {
  return value_case() == kFloatVal;
}
inline void AttributeProto::set_has_float_val() {
  _oneof_case_[0] = kFloatVal;
}
inline void AttributeProto::clear_float_val() {
  if (has_float_val()) {
    value_.float_val_ = 0;
    clear_has_value();
  }
}
inline float AttributeProto::float_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.float_val)
  if (has_float_val()) {
    return value_.float_val_;
  }
  return 0;
}
inline void AttributeProto::set_float_val(float value) {
  if (!has_float_val()) {
    clear_value();
    set_has_float_val();
  }
  value_.float_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.float_val)
}

// .ChakraProtoMsg.FloatList float_list = 6;
inline bool AttributeProto::has_float_list() const {
  return value_case() == kFloatList;
}
inline void AttributeProto::set_has_float_list() {
  _oneof_case_[0] = kFloatList;
}
inline void AttributeProto::clear_float_list() {
  if (has_float_list()) {
    delete value_.float_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::FloatList& AttributeProto::_internal_float_list() const {
  return *value_.float_list_;
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::release_float_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.float_list)
  if (has_float_list()) {
    clear_has_value();
      ::ChakraProtoMsg::FloatList* temp = value_.float_list_;
    value_.float_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::FloatList& AttributeProto::float_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.float_list)
  return has_float_list()
      ? *value_.float_list_
      : *reinterpret_cast< ::ChakraProtoMsg::FloatList*>(&::ChakraProtoMsg::_FloatList_default_instance_);
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::mutable_float_list() {
  if (!has_float_list()) {
    clear_value();
    set_has_float_list();
    value_.float_list_ = CreateMaybeMessage< ::ChakraProtoMsg::FloatList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.float_list)
  return value_.float_list_;
}

// int32 int32_val = 7;
inline bool AttributeProto::has_int32_val() const {
  return value_case() == kInt32Val;
}
inline void AttributeProto::set_has_int32_val() {
  _oneof_case_[0] = kInt32Val;
}
inline void AttributeProto::clear_int32_val() {
  if (has_int32_val()) {
    value_.int32_val_ = 0;
    clear_has_value();
  }
}
inline ::google::protobuf::int32 AttributeProto::int32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int32_val)
  if (has_int32_val()) {
    return value_.int32_val_;
  }
  return 0;
}
inline void AttributeProto::set_int32_val(::google::protobuf::int32 value) {
  if (!has_int32_val()) {
    clear_value();
    set_has_int32_val();
  }
  value_.int32_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.int32_val)
}

// .ChakraProtoMsg.Int32List int32_list = 8;
inline bool AttributeProto::has_int32_list() const {
  return value_case() == kInt32List;
}
inline void AttributeProto::set_has_int32_list() {
  _oneof_case_[0] = kInt32List;
}
inline void AttributeProto::clear_int32_list() {
  if (has_int32_list()) {
    delete value_.int32_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Int32List& AttributeProto::_internal_int32_list() const {
  return *value_.int32_list_;
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::release_int32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.int32_list)
  if (has_int32_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Int32List* temp = value_.int32_list_;
    value_.int32_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Int32List& AttributeProto::int32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int32_list)
  return has_int32_list()
      ? *value_.int32_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Int32List*>(&::ChakraProtoMsg::_Int32List_default_instance_);
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::mutable_int32_list() {
  if (!has_int32_list()) {
    clear_value();
    set_has_int32_list();
    value_.int32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Int32List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.int32_list)
  return value_.int32_list_;
}

// int64 int64_val = 9;
inline bool AttributeProto::has_int64_val() const {
  return value_case() == kInt64Val;
}
inline void AttributeProto::set_has_int64_val() {
  _oneof_case_[0] = kInt64Val;
}
inline void AttributeProto::clear_int64_val() {
  if (has_int64_val()) {
    value_.int64_val_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 AttributeProto::int64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int64_val)
  if (has_int64_val()) {
    return value_.int64_val_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void AttributeProto::set_int64_val(::google::protobuf::int64 value) {
  if (!has_int64_val()) {
    clear_value();
    set_has_int64_val();
  }
  value_.int64_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.int64_val)
}

// .ChakraProtoMsg.Int64List int64_list = 10;
inline bool AttributeProto::has_int64_list() const {
  return value_case() == kInt64List;
}
inline void AttributeProto::set_has_int64_list() {
  _oneof_case_[0] = kInt64List;
}
inline void AttributeProto::clear_int64_list() {
  if (has_int64_list()) {
    delete value_.int64_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Int64List& AttributeProto::_internal_int64_list() const {
  return *value_.int64_list_;
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::release_int64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.int64_list)
  if (has_int64_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Int64List* temp = value_.int64_list_;
    value_.int64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Int64List& AttributeProto::int64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int64_list)
  return has_int64_list()
      ? *value_.int64_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Int64List*>(&::ChakraProtoMsg::_Int64List_default_instance_);
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::mutable_int64_list() {
  if (!has_int64_list()) {
    clear_value();
    set_has_int64_list();
    value_.int64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Int64List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.int64_list)
  return value_.int64_list_;
}

// uint32 uint32_val = 11;
inline bool AttributeProto::has_uint32_val() const {
  return value_case() == kUint32Val;
}
inline void AttributeProto::set_has_uint32_val() {
  _oneof_case_[0] = kUint32Val;
}
inline void AttributeProto::clear_uint32_val() {
  if (has_uint32_val()) {
    value_.uint32_val_ = 0u;
    clear_has_value();
  }
}
inline ::google::protobuf::uint32 AttributeProto::uint32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint32_val)
  if (has_uint32_val()) {
    return value_.uint32_val_;
  }
  return 0u;
}
inline void AttributeProto::set_uint32_val(::google::protobuf::uint32 value) {
  if (!has_uint32_val()) {
    clear_value();
    set_has_uint32_val();
  }
  value_.uint32_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.uint32_val)
}

// .ChakraProtoMsg.Uint32List uint32_list = 12;
inline bool AttributeProto::has_uint32_list() const {
  return value_case() == kUint32List;
}
inline void AttributeProto::set_has_uint32_list() {
  _oneof_case_[0] = kUint32List;
}
inline void AttributeProto::clear_uint32_list() {
  if (has_uint32_list()) {
    delete value_.uint32_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Uint32List& AttributeProto::_internal_uint32_list() const {
  return *value_.uint32_list_;
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::release_uint32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.uint32_list)
  if (has_uint32_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Uint32List* temp = value_.uint32_list_;
    value_.uint32_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Uint32List& AttributeProto::uint32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint32_list)
  return has_uint32_list()
      ? *value_.uint32_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Uint32List*>(&::ChakraProtoMsg::_Uint32List_default_instance_);
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::mutable_uint32_list() {
  if (!has_uint32_list()) {
    clear_value();
    set_has_uint32_list();
    value_.uint32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Uint32List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.uint32_list)
  return value_.uint32_list_;
}

// uint64 uint64_val = 13;
inline bool AttributeProto::has_uint64_val() const {
  return value_case() == kUint64Val;
}
inline void AttributeProto::set_has_uint64_val() {
  _oneof_case_[0] = kUint64Val;
}
inline void AttributeProto::clear_uint64_val() {
  if (has_uint64_val()) {
    value_.uint64_val_ = GOOGLE_ULONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::uint64 AttributeProto::uint64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint64_val)
  if (has_uint64_val()) {
    return value_.uint64_val_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void AttributeProto::set_uint64_val(::google::protobuf::uint64 value) {
  if (!has_uint64_val()) {
    clear_value();
    set_has_uint64_val();
  }
  value_.uint64_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.uint64_val)
}

// .ChakraProtoMsg.Uint64List uint64_list = 14;
inline bool AttributeProto::has_uint64_list() const {
  return value_case() == kUint64List;
}
inline void AttributeProto::set_has_uint64_list() {
  _oneof_case_[0] = kUint64List;
}
inline void AttributeProto::clear_uint64_list() {
  if (has_uint64_list()) {
    delete value_.uint64_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Uint64List& AttributeProto::_internal_uint64_list() const {
  return *value_.uint64_list_;
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::release_uint64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.uint64_list)
  if (has_uint64_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Uint64List* temp = value_.uint64_list_;
    value_.uint64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Uint64List& AttributeProto::uint64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint64_list)
  return has_uint64_list()
      ? *value_.uint64_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Uint64List*>(&::ChakraProtoMsg::_Uint64List_default_instance_);
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::mutable_uint64_list() {
  if (!has_uint64_list()) {
    clear_value();
    set_has_uint64_list();
    value_.uint64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Uint64List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.uint64_list)
  return value_.uint64_list_;
}

// sint32 sint32_val = 15;
inline bool AttributeProto::has_sint32_val() const {
  return value_case() == kSint32Val;
}
inline void AttributeProto::set_has_sint32_val() {
  _oneof_case_[0] = kSint32Val;
}
inline void AttributeProto::clear_sint32_val() {
  if (has_sint32_val()) {
    value_.sint32_val_ = 0;
    clear_has_value();
  }
}
inline ::google::protobuf::int32 AttributeProto::sint32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint32_val)
  if (has_sint32_val()) {
    return value_.sint32_val_;
  }
  return 0;
}
inline void AttributeProto::set_sint32_val(::google::protobuf::int32 value) {
  if (!has_sint32_val()) {
    clear_value();
    set_has_sint32_val();
  }
  value_.sint32_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sint32_val)
}

// .ChakraProtoMsg.Sint32List sint32_list = 16;
inline bool AttributeProto::has_sint32_list() const {
  return value_case() == kSint32List;
}
inline void AttributeProto::set_has_sint32_list() {
  _oneof_case_[0] = kSint32List;
}
inline void AttributeProto::clear_sint32_list() {
  if (has_sint32_list()) {
    delete value_.sint32_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Sint32List& AttributeProto::_internal_sint32_list() const {
  return *value_.sint32_list_;
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::release_sint32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sint32_list)
  if (has_sint32_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Sint32List* temp = value_.sint32_list_;
    value_.sint32_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Sint32List& AttributeProto::sint32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint32_list)
  return has_sint32_list()
      ? *value_.sint32_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Sint32List*>(&::ChakraProtoMsg::_Sint32List_default_instance_);
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::mutable_sint32_list() {
  if (!has_sint32_list()) {
    clear_value();
    set_has_sint32_list();
    value_.sint32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Sint32List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sint32_list)
  return value_.sint32_list_;
}

// sint64 sint64_val = 17;
inline bool AttributeProto::has_sint64_val() const {
  return value_case() == kSint64Val;
}
inline void AttributeProto::set_has_sint64_val() {
  _oneof_case_[0] = kSint64Val;
}
inline void AttributeProto::clear_sint64_val() {
  if (has_sint64_val()) {
    value_.sint64_val_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 AttributeProto::sint64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint64_val)
  if (has_sint64_val()) {
    return value_.sint64_val_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void AttributeProto::set_sint64_val(::google::protobuf::int64 value) {
  if (!has_sint64_val()) {
    clear_value();
    set_has_sint64_val();
  }
  value_.sint64_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sint64_val)
}

// .ChakraProtoMsg.Sint64List sint64_list = 18;
inline bool AttributeProto::has_sint64_list() const {
  return value_case() == kSint64List;
}
inline void AttributeProto::set_has_sint64_list() {
  _oneof_case_[0] = kSint64List;
}
inline void AttributeProto::clear_sint64_list() {
  if (has_sint64_list()) {
    delete value_.sint64_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Sint64List& AttributeProto::_internal_sint64_list() const {
  return *value_.sint64_list_;
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::release_sint64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sint64_list)
  if (has_sint64_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Sint64List* temp = value_.sint64_list_;
    value_.sint64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Sint64List& AttributeProto::sint64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint64_list)
  return has_sint64_list()
      ? *value_.sint64_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Sint64List*>(&::ChakraProtoMsg::_Sint64List_default_instance_);
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::mutable_sint64_list() {
  if (!has_sint64_list()) {
    clear_value();
    set_has_sint64_list();
    value_.sint64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Sint64List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sint64_list)
  return value_.sint64_list_;
}

// fixed32 fixed32_val = 19;
inline bool AttributeProto::has_fixed32_val() const {
  return value_case() == kFixed32Val;
}
inline void AttributeProto::set_has_fixed32_val() {
  _oneof_case_[0] = kFixed32Val;
}
inline void AttributeProto::clear_fixed32_val() {
  if (has_fixed32_val()) {
    value_.fixed32_val_ = 0u;
    clear_has_value();
  }
}
inline ::google::protobuf::uint32 AttributeProto::fixed32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed32_val)
  if (has_fixed32_val()) {
    return value_.fixed32_val_;
  }
  return 0u;
}
inline void AttributeProto::set_fixed32_val(::google::protobuf::uint32 value) {
  if (!has_fixed32_val()) {
    clear_value();
    set_has_fixed32_val();
  }
  value_.fixed32_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.fixed32_val)
}

// .ChakraProtoMsg.Fixed32List fixed32_list = 20;
inline bool AttributeProto::has_fixed32_list() const {
  return value_case() == kFixed32List;
}
inline void AttributeProto::set_has_fixed32_list() {
  _oneof_case_[0] = kFixed32List;
}
inline void AttributeProto::clear_fixed32_list() {
  if (has_fixed32_list()) {
    delete value_.fixed32_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Fixed32List& AttributeProto::_internal_fixed32_list() const {
  return *value_.fixed32_list_;
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::release_fixed32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.fixed32_list)
  if (has_fixed32_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Fixed32List* temp = value_.fixed32_list_;
    value_.fixed32_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Fixed32List& AttributeProto::fixed32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed32_list)
  return has_fixed32_list()
      ? *value_.fixed32_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Fixed32List*>(&::ChakraProtoMsg::_Fixed32List_default_instance_);
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::mutable_fixed32_list() {
  if (!has_fixed32_list()) {
    clear_value();
    set_has_fixed32_list();
    value_.fixed32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Fixed32List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.fixed32_list)
  return value_.fixed32_list_;
}

// fixed64 fixed64_val = 21;
inline bool AttributeProto::has_fixed64_val() const {
  return value_case() == kFixed64Val;
}
inline void AttributeProto::set_has_fixed64_val() {
  _oneof_case_[0] = kFixed64Val;
}
inline void AttributeProto::clear_fixed64_val() {
  if (has_fixed64_val()) {
    value_.fixed64_val_ = GOOGLE_ULONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::uint64 AttributeProto::fixed64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed64_val)
  if (has_fixed64_val()) {
    return value_.fixed64_val_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void AttributeProto::set_fixed64_val(::google::protobuf::uint64 value) {
  if (!has_fixed64_val()) {
    clear_value();
    set_has_fixed64_val();
  }
  value_.fixed64_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.fixed64_val)
}

// .ChakraProtoMsg.Fixed64List fixed64_list = 22;
inline bool AttributeProto::has_fixed64_list() const {
  return value_case() == kFixed64List;
}
inline void AttributeProto::set_has_fixed64_list() {
  _oneof_case_[0] = kFixed64List;
}
inline void AttributeProto::clear_fixed64_list() {
  if (has_fixed64_list()) {
    delete value_.fixed64_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Fixed64List& AttributeProto::_internal_fixed64_list() const {
  return *value_.fixed64_list_;
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::release_fixed64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.fixed64_list)
  if (has_fixed64_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Fixed64List* temp = value_.fixed64_list_;
    value_.fixed64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Fixed64List& AttributeProto::fixed64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed64_list)
  return has_fixed64_list()
      ? *value_.fixed64_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Fixed64List*>(&::ChakraProtoMsg::_Fixed64List_default_instance_);
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::mutable_fixed64_list() {
  if (!has_fixed64_list()) {
    clear_value();
    set_has_fixed64_list();
    value_.fixed64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Fixed64List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.fixed64_list)
  return value_.fixed64_list_;
}

// sfixed32 sfixed32_val = 23;
inline bool AttributeProto::has_sfixed32_val() const {
  return value_case() == kSfixed32Val;
}
inline void AttributeProto::set_has_sfixed32_val() {
  _oneof_case_[0] = kSfixed32Val;
}
inline void AttributeProto::clear_sfixed32_val() {
  if (has_sfixed32_val()) {
    value_.sfixed32_val_ = 0;
    clear_has_value();
  }
}
inline ::google::protobuf::int32 AttributeProto::sfixed32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed32_val)
  if (has_sfixed32_val()) {
    return value_.sfixed32_val_;
  }
  return 0;
}
inline void AttributeProto::set_sfixed32_val(::google::protobuf::int32 value) {
  if (!has_sfixed32_val()) {
    clear_value();
    set_has_sfixed32_val();
  }
  value_.sfixed32_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sfixed32_val)
}

// .ChakraProtoMsg.Sfixed32List sfixed32_list = 24;
inline bool AttributeProto::has_sfixed32_list() const {
  return value_case() == kSfixed32List;
}
inline void AttributeProto::set_has_sfixed32_list() {
  _oneof_case_[0] = kSfixed32List;
}
inline void AttributeProto::clear_sfixed32_list() {
  if (has_sfixed32_list()) {
    delete value_.sfixed32_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Sfixed32List& AttributeProto::_internal_sfixed32_list() const {
  return *value_.sfixed32_list_;
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::release_sfixed32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sfixed32_list)
  if (has_sfixed32_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Sfixed32List* temp = value_.sfixed32_list_;
    value_.sfixed32_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Sfixed32List& AttributeProto::sfixed32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed32_list)
  return has_sfixed32_list()
      ? *value_.sfixed32_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Sfixed32List*>(&::ChakraProtoMsg::_Sfixed32List_default_instance_);
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::mutable_sfixed32_list() {
  if (!has_sfixed32_list()) {
    clear_value();
    set_has_sfixed32_list();
    value_.sfixed32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Sfixed32List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sfixed32_list)
  return value_.sfixed32_list_;
}

// sfixed64 sfixed64_val = 25;
inline bool AttributeProto::has_sfixed64_val() const {
  return value_case() == kSfixed64Val;
}
inline void AttributeProto::set_has_sfixed64_val() {
  _oneof_case_[0] = kSfixed64Val;
}
inline void AttributeProto::clear_sfixed64_val() {
  if (has_sfixed64_val()) {
    value_.sfixed64_val_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 AttributeProto::sfixed64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed64_val)
  if (has_sfixed64_val()) {
    return value_.sfixed64_val_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void AttributeProto::set_sfixed64_val(::google::protobuf::int64 value) {
  if (!has_sfixed64_val()) {
    clear_value();
    set_has_sfixed64_val();
  }
  value_.sfixed64_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sfixed64_val)
}

// .ChakraProtoMsg.Sfixed64List sfixed64_list = 26;
inline bool AttributeProto::has_sfixed64_list() const {
  return value_case() == kSfixed64List;
}
inline void AttributeProto::set_has_sfixed64_list() {
  _oneof_case_[0] = kSfixed64List;
}
inline void AttributeProto::clear_sfixed64_list() {
  if (has_sfixed64_list()) {
    delete value_.sfixed64_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::Sfixed64List& AttributeProto::_internal_sfixed64_list() const {
  return *value_.sfixed64_list_;
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::release_sfixed64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sfixed64_list)
  if (has_sfixed64_list()) {
    clear_has_value();
      ::ChakraProtoMsg::Sfixed64List* temp = value_.sfixed64_list_;
    value_.sfixed64_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::Sfixed64List& AttributeProto::sfixed64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed64_list)
  return has_sfixed64_list()
      ? *value_.sfixed64_list_
      : *reinterpret_cast< ::ChakraProtoMsg::Sfixed64List*>(&::ChakraProtoMsg::_Sfixed64List_default_instance_);
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::mutable_sfixed64_list() {
  if (!has_sfixed64_list()) {
    clear_value();
    set_has_sfixed64_list();
    value_.sfixed64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Sfixed64List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sfixed64_list)
  return value_.sfixed64_list_;
}

// bool bool_val = 27;
inline bool AttributeProto::has_bool_val() const {
  return value_case() == kBoolVal;
}
inline void AttributeProto::set_has_bool_val() {
  _oneof_case_[0] = kBoolVal;
}
inline void AttributeProto::clear_bool_val() {
  if (has_bool_val()) {
    value_.bool_val_ = false;
    clear_has_value();
  }
}
inline bool AttributeProto::bool_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bool_val)
  if (has_bool_val()) {
    return value_.bool_val_;
  }
  return false;
}
inline void AttributeProto::set_bool_val(bool value) {
  if (!has_bool_val()) {
    clear_value();
    set_has_bool_val();
  }
  value_.bool_val_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.bool_val)
}

// .ChakraProtoMsg.BoolList bool_list = 28;
inline bool AttributeProto::has_bool_list() const {
  return value_case() == kBoolList;
}
inline void AttributeProto::set_has_bool_list() {
  _oneof_case_[0] = kBoolList;
}
inline void AttributeProto::clear_bool_list() {
  if (has_bool_list()) {
    delete value_.bool_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::BoolList& AttributeProto::_internal_bool_list() const {
  return *value_.bool_list_;
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::release_bool_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.bool_list)
  if (has_bool_list()) {
    clear_has_value();
      ::ChakraProtoMsg::BoolList* temp = value_.bool_list_;
    value_.bool_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::BoolList& AttributeProto::bool_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bool_list)
  return has_bool_list()
      ? *value_.bool_list_
      : *reinterpret_cast< ::ChakraProtoMsg::BoolList*>(&::ChakraProtoMsg::_BoolList_default_instance_);
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::mutable_bool_list() {
  if (!has_bool_list()) {
    clear_value();
    set_has_bool_list();
    value_.bool_list_ = CreateMaybeMessage< ::ChakraProtoMsg::BoolList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.bool_list)
  return value_.bool_list_;
}

// string string_val = 29;
inline bool AttributeProto::has_string_val() const {
  return value_case() == kStringVal;
}
inline void AttributeProto::set_has_string_val() {
  _oneof_case_[0] = kStringVal;
}
inline void AttributeProto::clear_string_val() {
  if (has_string_val()) {
    value_.string_val_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& AttributeProto::string_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.string_val)
  if (has_string_val()) {
    return value_.string_val_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AttributeProto::set_string_val(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.string_val)
  if (!has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.string_val)
}
#if LANG_CXX11
inline void AttributeProto::set_string_val(::std::string&& value) {
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.string_val)
  if (!has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.AttributeProto.string_val)
}
#endif
inline void AttributeProto::set_string_val(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.AttributeProto.string_val)
}
inline void AttributeProto::set_string_val(const char* value, size_t size) {
  if (!has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.AttributeProto.string_val)
}
inline ::std::string* AttributeProto::mutable_string_val() {
  if (!has_string_val()) {
    clear_value();
    set_has_string_val();
    value_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.string_val)
  return value_.string_val_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttributeProto::release_string_val() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.string_val)
  if (has_string_val()) {
    clear_has_value();
    return value_.string_val_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AttributeProto::set_allocated_string_val(::std::string* string_val) {
  if (!has_string_val()) {
    value_.string_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (string_val != NULL) {
    set_has_string_val();
    value_.string_val_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), string_val);
  }
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.string_val)
}

// .ChakraProtoMsg.StringList string_list = 30;
inline bool AttributeProto::has_string_list() const {
  return value_case() == kStringList;
}
inline void AttributeProto::set_has_string_list() {
  _oneof_case_[0] = kStringList;
}
inline void AttributeProto::clear_string_list() {
  if (has_string_list()) {
    delete value_.string_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::StringList& AttributeProto::_internal_string_list() const {
  return *value_.string_list_;
}
inline ::ChakraProtoMsg::StringList* AttributeProto::release_string_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.string_list)
  if (has_string_list()) {
    clear_has_value();
      ::ChakraProtoMsg::StringList* temp = value_.string_list_;
    value_.string_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::StringList& AttributeProto::string_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.string_list)
  return has_string_list()
      ? *value_.string_list_
      : *reinterpret_cast< ::ChakraProtoMsg::StringList*>(&::ChakraProtoMsg::_StringList_default_instance_);
}
inline ::ChakraProtoMsg::StringList* AttributeProto::mutable_string_list() {
  if (!has_string_list()) {
    clear_value();
    set_has_string_list();
    value_.string_list_ = CreateMaybeMessage< ::ChakraProtoMsg::StringList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.string_list)
  return value_.string_list_;
}

// bytes bytes_val = 31;
inline bool AttributeProto::has_bytes_val() const {
  return value_case() == kBytesVal;
}
inline void AttributeProto::set_has_bytes_val() {
  _oneof_case_[0] = kBytesVal;
}
inline void AttributeProto::clear_bytes_val() {
  if (has_bytes_val()) {
    value_.bytes_val_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& AttributeProto::bytes_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bytes_val)
  if (has_bytes_val()) {
    return value_.bytes_val_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AttributeProto::set_bytes_val(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.bytes_val)
  if (!has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.bytes_val)
}
#if LANG_CXX11
inline void AttributeProto::set_bytes_val(::std::string&& value) {
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.bytes_val)
  if (!has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.AttributeProto.bytes_val)
}
#endif
inline void AttributeProto::set_bytes_val(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.AttributeProto.bytes_val)
}
inline void AttributeProto::set_bytes_val(const void* value, size_t size) {
  if (!has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.bytes_val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.AttributeProto.bytes_val)
}
inline ::std::string* AttributeProto::mutable_bytes_val() {
  if (!has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    value_.bytes_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.bytes_val)
  return value_.bytes_val_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttributeProto::release_bytes_val() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.bytes_val)
  if (has_bytes_val()) {
    clear_has_value();
    return value_.bytes_val_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AttributeProto::set_allocated_bytes_val(::std::string* bytes_val) {
  if (!has_bytes_val()) {
    value_.bytes_val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (bytes_val != NULL) {
    set_has_bytes_val();
    value_.bytes_val_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bytes_val);
  }
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.bytes_val)
}

// .ChakraProtoMsg.BytesList bytes_list = 32;
inline bool AttributeProto::has_bytes_list() const {
  return value_case() == kBytesList;
}
inline void AttributeProto::set_has_bytes_list() {
  _oneof_case_[0] = kBytesList;
}
inline void AttributeProto::clear_bytes_list() {
  if (has_bytes_list()) {
    delete value_.bytes_list_;
    clear_has_value();
  }
}
inline const ::ChakraProtoMsg::BytesList& AttributeProto::_internal_bytes_list() const {
  return *value_.bytes_list_;
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::release_bytes_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.bytes_list)
  if (has_bytes_list()) {
    clear_has_value();
      ::ChakraProtoMsg::BytesList* temp = value_.bytes_list_;
    value_.bytes_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ChakraProtoMsg::BytesList& AttributeProto::bytes_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bytes_list)
  return has_bytes_list()
      ? *value_.bytes_list_
      : *reinterpret_cast< ::ChakraProtoMsg::BytesList*>(&::ChakraProtoMsg::_BytesList_default_instance_);
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::mutable_bytes_list() {
  if (!has_bytes_list()) {
    clear_value();
    set_has_bytes_list();
    value_.bytes_list_ = CreateMaybeMessage< ::ChakraProtoMsg::BytesList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.bytes_list)
  return value_.bytes_list_;
}

inline bool AttributeProto::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AttributeProto::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline AttributeProto::ValueCase AttributeProto::value_case() const {
  return AttributeProto::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DoubleList

// repeated double values = 1;
inline int DoubleList::values_size() const {
  return values_.size();
}
inline void DoubleList::clear_values() {
  values_.Clear();
}
inline double DoubleList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.DoubleList.values)
  return values_.Get(index);
}
inline void DoubleList::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.DoubleList.values)
}
inline void DoubleList::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.DoubleList.values)
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.DoubleList.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.DoubleList.values)
  return &values_;
}

// -------------------------------------------------------------------

// FloatList

// repeated float values = 1;
inline int FloatList::values_size() const {
  return values_.size();
}
inline void FloatList::clear_values() {
  values_.Clear();
}
inline float FloatList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.FloatList.values)
  return values_.Get(index);
}
inline void FloatList::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.FloatList.values)
}
inline void FloatList::add_values(float value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.FloatList.values)
}
inline const ::google::protobuf::RepeatedField< float >&
FloatList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.FloatList.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< float >*
FloatList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.FloatList.values)
  return &values_;
}

// -------------------------------------------------------------------

// Int32List

// repeated int32 values = 1;
inline int Int32List::values_size() const {
  return values_.size();
}
inline void Int32List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int32 Int32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Int32List.values)
  return values_.Get(index);
}
inline void Int32List::set_values(int index, ::google::protobuf::int32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Int32List.values)
}
inline void Int32List::add_values(::google::protobuf::int32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Int32List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Int32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Int32List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Int32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Int32List.values)
  return &values_;
}

// -------------------------------------------------------------------

// Int64List

// repeated int64 values = 1;
inline int Int64List::values_size() const {
  return values_.size();
}
inline void Int64List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int64 Int64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Int64List.values)
  return values_.Get(index);
}
inline void Int64List::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Int64List.values)
}
inline void Int64List::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Int64List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Int64List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Int64List.values)
  return &values_;
}

// -------------------------------------------------------------------

// Uint32List

// repeated uint32 values = 1;
inline int Uint32List::values_size() const {
  return values_.size();
}
inline void Uint32List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint32 Uint32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Uint32List.values)
  return values_.Get(index);
}
inline void Uint32List::set_values(int index, ::google::protobuf::uint32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Uint32List.values)
}
inline void Uint32List::add_values(::google::protobuf::uint32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Uint32List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Uint32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Uint32List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Uint32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Uint32List.values)
  return &values_;
}

// -------------------------------------------------------------------

// Uint64List

// repeated uint64 values = 1;
inline int Uint64List::values_size() const {
  return values_.size();
}
inline void Uint64List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint64 Uint64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Uint64List.values)
  return values_.Get(index);
}
inline void Uint64List::set_values(int index, ::google::protobuf::uint64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Uint64List.values)
}
inline void Uint64List::add_values(::google::protobuf::uint64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Uint64List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Uint64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Uint64List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Uint64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Uint64List.values)
  return &values_;
}

// -------------------------------------------------------------------

// Sint32List

// repeated sint32 values = 1;
inline int Sint32List::values_size() const {
  return values_.size();
}
inline void Sint32List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int32 Sint32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sint32List.values)
  return values_.Get(index);
}
inline void Sint32List::set_values(int index, ::google::protobuf::int32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sint32List.values)
}
inline void Sint32List::add_values(::google::protobuf::int32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sint32List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Sint32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sint32List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Sint32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sint32List.values)
  return &values_;
}

// -------------------------------------------------------------------

// Sint64List

// repeated sint64 values = 1;
inline int Sint64List::values_size() const {
  return values_.size();
}
inline void Sint64List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int64 Sint64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sint64List.values)
  return values_.Get(index);
}
inline void Sint64List::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sint64List.values)
}
inline void Sint64List::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sint64List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Sint64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sint64List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Sint64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sint64List.values)
  return &values_;
}

// -------------------------------------------------------------------

// Fixed32List

// repeated fixed32 values = 1;
inline int Fixed32List::values_size() const {
  return values_.size();
}
inline void Fixed32List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint32 Fixed32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Fixed32List.values)
  return values_.Get(index);
}
inline void Fixed32List::set_values(int index, ::google::protobuf::uint32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Fixed32List.values)
}
inline void Fixed32List::add_values(::google::protobuf::uint32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Fixed32List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Fixed32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Fixed32List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Fixed32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Fixed32List.values)
  return &values_;
}

// -------------------------------------------------------------------

// Fixed64List

// repeated fixed64 values = 1;
inline int Fixed64List::values_size() const {
  return values_.size();
}
inline void Fixed64List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::uint64 Fixed64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Fixed64List.values)
  return values_.Get(index);
}
inline void Fixed64List::set_values(int index, ::google::protobuf::uint64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Fixed64List.values)
}
inline void Fixed64List::add_values(::google::protobuf::uint64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Fixed64List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Fixed64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Fixed64List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Fixed64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Fixed64List.values)
  return &values_;
}

// -------------------------------------------------------------------

// Sfixed32List

// repeated sfixed32 values = 1;
inline int Sfixed32List::values_size() const {
  return values_.size();
}
inline void Sfixed32List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int32 Sfixed32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sfixed32List.values)
  return values_.Get(index);
}
inline void Sfixed32List::set_values(int index, ::google::protobuf::int32 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sfixed32List.values)
}
inline void Sfixed32List::add_values(::google::protobuf::int32 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sfixed32List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Sfixed32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sfixed32List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Sfixed32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sfixed32List.values)
  return &values_;
}

// -------------------------------------------------------------------

// Sfixed64List

// repeated sfixed64 values = 1;
inline int Sfixed64List::values_size() const {
  return values_.size();
}
inline void Sfixed64List::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int64 Sfixed64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sfixed64List.values)
  return values_.Get(index);
}
inline void Sfixed64List::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sfixed64List.values)
}
inline void Sfixed64List::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sfixed64List.values)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Sfixed64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sfixed64List.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Sfixed64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sfixed64List.values)
  return &values_;
}

// -------------------------------------------------------------------

// BoolList

// repeated bool values = 1;
inline int BoolList::values_size() const {
  return values_.size();
}
inline void BoolList::clear_values() {
  values_.Clear();
}
inline bool BoolList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.BoolList.values)
  return values_.Get(index);
}
inline void BoolList::set_values(int index, bool value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.BoolList.values)
}
inline void BoolList::add_values(bool value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.BoolList.values)
}
inline const ::google::protobuf::RepeatedField< bool >&
BoolList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.BoolList.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< bool >*
BoolList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.BoolList.values)
  return &values_;
}

// -------------------------------------------------------------------

// StringList

// repeated string values = 1;
inline int StringList::values_size() const {
  return values_.size();
}
inline void StringList::clear_values() {
  values_.Clear();
}
inline const ::std::string& StringList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.StringList.values)
  return values_.Get(index);
}
inline ::std::string* StringList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.StringList.values)
  return values_.Mutable(index);
}
inline void StringList::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.StringList.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringList::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.StringList.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringList::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.StringList.values)
}
inline void StringList::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.StringList.values)
}
inline ::std::string* StringList::add_values() {
  // @@protoc_insertion_point(field_add_mutable:ChakraProtoMsg.StringList.values)
  return values_.Add();
}
inline void StringList::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.StringList.values)
}
#if LANG_CXX11
inline void StringList::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.StringList.values)
}
#endif
inline void StringList::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ChakraProtoMsg.StringList.values)
}
inline void StringList::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ChakraProtoMsg.StringList.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.StringList.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.StringList.values)
  return &values_;
}

// -------------------------------------------------------------------

// BytesList

// repeated bytes values = 1;
inline int BytesList::values_size() const {
  return values_.size();
}
inline void BytesList::clear_values() {
  values_.Clear();
}
inline const ::std::string& BytesList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.BytesList.values)
  return values_.Get(index);
}
inline ::std::string* BytesList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.BytesList.values)
  return values_.Mutable(index);
}
inline void BytesList::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.BytesList.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BytesList::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.BytesList.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BytesList::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::set_values(int index, const void* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.BytesList.values)
}
inline ::std::string* BytesList::add_values() {
  // @@protoc_insertion_point(field_add_mutable:ChakraProtoMsg.BytesList.values)
  return values_.Add();
}
inline void BytesList::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.BytesList.values)
}
#if LANG_CXX11
inline void BytesList::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.BytesList.values)
}
#endif
inline void BytesList::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::add_values(const void* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ChakraProtoMsg.BytesList.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BytesList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.BytesList.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BytesList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.BytesList.values)
  return &values_;
}

// -------------------------------------------------------------------

// GlobalMetadata

// string version = 1;
inline void GlobalMetadata::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GlobalMetadata::version() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.GlobalMetadata.version)
  return version_.GetNoArena();
}
inline void GlobalMetadata::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.GlobalMetadata.version)
}
#if LANG_CXX11
inline void GlobalMetadata::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.GlobalMetadata.version)
}
#endif
inline void GlobalMetadata::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.GlobalMetadata.version)
}
inline void GlobalMetadata::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.GlobalMetadata.version)
}
inline ::std::string* GlobalMetadata::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.GlobalMetadata.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GlobalMetadata::release_version() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.GlobalMetadata.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GlobalMetadata::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.GlobalMetadata.version)
}

// repeated .ChakraProtoMsg.AttributeProto attr = 2;
inline int GlobalMetadata::attr_size() const {
  return attr_.size();
}
inline void GlobalMetadata::clear_attr() {
  attr_.Clear();
}
inline ::ChakraProtoMsg::AttributeProto* GlobalMetadata::mutable_attr(int index) {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.GlobalMetadata.attr)
  return attr_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
GlobalMetadata::mutable_attr() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.GlobalMetadata.attr)
  return &attr_;
}
inline const ::ChakraProtoMsg::AttributeProto& GlobalMetadata::attr(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.GlobalMetadata.attr)
  return attr_.Get(index);
}
inline ::ChakraProtoMsg::AttributeProto* GlobalMetadata::add_attr() {
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.GlobalMetadata.attr)
  return attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
GlobalMetadata::attr() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.GlobalMetadata.attr)
  return attr_;
}

// -------------------------------------------------------------------

// Node

// uint64 id = 1;
inline void Node::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Node::id() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.id)
  return id_;
}
inline void Node::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.id)
}

// string name = 2;
inline void Node::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.name)
  return name_.GetNoArena();
}
inline void Node::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.name)
}
#if LANG_CXX11
inline void Node::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.Node.name)
}
#endif
inline void Node::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.Node.name)
}
inline void Node::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.Node.name)
}
inline ::std::string* Node::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Node.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Node.name)
}

// .ChakraProtoMsg.NodeType type = 3;
inline void Node::clear_type() {
  type_ = 0;
}
inline ::ChakraProtoMsg::NodeType Node::type() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.type)
  return static_cast< ::ChakraProtoMsg::NodeType >(type_);
}
inline void Node::set_type(::ChakraProtoMsg::NodeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.type)
}

// repeated uint64 ctrl_deps = 4;
inline int Node::ctrl_deps_size() const {
  return ctrl_deps_.size();
}
inline void Node::clear_ctrl_deps() {
  ctrl_deps_.Clear();
}
inline ::google::protobuf::uint64 Node::ctrl_deps(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.ctrl_deps)
  return ctrl_deps_.Get(index);
}
inline void Node::set_ctrl_deps(int index, ::google::protobuf::uint64 value) {
  ctrl_deps_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.ctrl_deps)
}
inline void Node::add_ctrl_deps(::google::protobuf::uint64 value) {
  ctrl_deps_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Node.ctrl_deps)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Node::ctrl_deps() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Node.ctrl_deps)
  return ctrl_deps_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Node::mutable_ctrl_deps() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Node.ctrl_deps)
  return &ctrl_deps_;
}

// repeated uint64 data_deps = 5;
inline int Node::data_deps_size() const {
  return data_deps_.size();
}
inline void Node::clear_data_deps() {
  data_deps_.Clear();
}
inline ::google::protobuf::uint64 Node::data_deps(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.data_deps)
  return data_deps_.Get(index);
}
inline void Node::set_data_deps(int index, ::google::protobuf::uint64 value) {
  data_deps_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.data_deps)
}
inline void Node::add_data_deps(::google::protobuf::uint64 value) {
  data_deps_.Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Node.data_deps)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Node::data_deps() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Node.data_deps)
  return data_deps_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Node::mutable_data_deps() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Node.data_deps)
  return &data_deps_;
}

// uint64 start_time_micros = 6;
inline void Node::clear_start_time_micros() {
  start_time_micros_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Node::start_time_micros() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.start_time_micros)
  return start_time_micros_;
}
inline void Node::set_start_time_micros(::google::protobuf::uint64 value) {
  
  start_time_micros_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.start_time_micros)
}

// uint64 duration_micros = 7;
inline void Node::clear_duration_micros() {
  duration_micros_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Node::duration_micros() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.duration_micros)
  return duration_micros_;
}
inline void Node::set_duration_micros(::google::protobuf::uint64 value) {
  
  duration_micros_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.duration_micros)
}

// .ChakraProtoMsg.IOInfo inputs = 8;
inline bool Node::has_inputs() const {
  return this != internal_default_instance() && inputs_ != NULL;
}
inline void Node::clear_inputs() {
  if (GetArenaNoVirtual() == NULL && inputs_ != NULL) {
    delete inputs_;
  }
  inputs_ = NULL;
}
inline const ::ChakraProtoMsg::IOInfo& Node::_internal_inputs() const {
  return *inputs_;
}
inline const ::ChakraProtoMsg::IOInfo& Node::inputs() const {
  const ::ChakraProtoMsg::IOInfo* p = inputs_;
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.inputs)
  return p != NULL ? *p : *reinterpret_cast<const ::ChakraProtoMsg::IOInfo*>(
      &::ChakraProtoMsg::_IOInfo_default_instance_);
}
inline ::ChakraProtoMsg::IOInfo* Node::release_inputs() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Node.inputs)
  
  ::ChakraProtoMsg::IOInfo* temp = inputs_;
  inputs_ = NULL;
  return temp;
}
inline ::ChakraProtoMsg::IOInfo* Node::mutable_inputs() {
  
  if (inputs_ == NULL) {
    auto* p = CreateMaybeMessage<::ChakraProtoMsg::IOInfo>(GetArenaNoVirtual());
    inputs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.inputs)
  return inputs_;
}
inline void Node::set_allocated_inputs(::ChakraProtoMsg::IOInfo* inputs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete inputs_;
  }
  if (inputs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      inputs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Node.inputs)
}

// .ChakraProtoMsg.IOInfo outputs = 9;
inline bool Node::has_outputs() const {
  return this != internal_default_instance() && outputs_ != NULL;
}
inline void Node::clear_outputs() {
  if (GetArenaNoVirtual() == NULL && outputs_ != NULL) {
    delete outputs_;
  }
  outputs_ = NULL;
}
inline const ::ChakraProtoMsg::IOInfo& Node::_internal_outputs() const {
  return *outputs_;
}
inline const ::ChakraProtoMsg::IOInfo& Node::outputs() const {
  const ::ChakraProtoMsg::IOInfo* p = outputs_;
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.outputs)
  return p != NULL ? *p : *reinterpret_cast<const ::ChakraProtoMsg::IOInfo*>(
      &::ChakraProtoMsg::_IOInfo_default_instance_);
}
inline ::ChakraProtoMsg::IOInfo* Node::release_outputs() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Node.outputs)
  
  ::ChakraProtoMsg::IOInfo* temp = outputs_;
  outputs_ = NULL;
  return temp;
}
inline ::ChakraProtoMsg::IOInfo* Node::mutable_outputs() {
  
  if (outputs_ == NULL) {
    auto* p = CreateMaybeMessage<::ChakraProtoMsg::IOInfo>(GetArenaNoVirtual());
    outputs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.outputs)
  return outputs_;
}
inline void Node::set_allocated_outputs(::ChakraProtoMsg::IOInfo* outputs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete outputs_;
  }
  if (outputs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      outputs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, outputs, submessage_arena);
    }
    
  } else {
    
  }
  outputs_ = outputs;
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Node.outputs)
}

// repeated .ChakraProtoMsg.AttributeProto attr = 10;
inline int Node::attr_size() const {
  return attr_.size();
}
inline void Node::clear_attr() {
  attr_.Clear();
}
inline ::ChakraProtoMsg::AttributeProto* Node::mutable_attr(int index) {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.attr)
  return attr_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
Node::mutable_attr() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Node.attr)
  return &attr_;
}
inline const ::ChakraProtoMsg::AttributeProto& Node::attr(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.attr)
  return attr_.Get(index);
}
inline ::ChakraProtoMsg::AttributeProto* Node::add_attr() {
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Node.attr)
  return attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
Node::attr() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Node.attr)
  return attr_;
}

// -------------------------------------------------------------------

// IOInfo

// string values = 1;
inline void IOInfo::clear_values() {
  values_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IOInfo::values() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.IOInfo.values)
  return values_.GetNoArena();
}
inline void IOInfo::set_values(const ::std::string& value) {
  
  values_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.IOInfo.values)
}
#if LANG_CXX11
inline void IOInfo::set_values(::std::string&& value) {
  
  values_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.IOInfo.values)
}
#endif
inline void IOInfo::set_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  values_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.IOInfo.values)
}
inline void IOInfo::set_values(const char* value, size_t size) {
  
  values_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.IOInfo.values)
}
inline ::std::string* IOInfo::mutable_values() {
  
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.IOInfo.values)
  return values_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IOInfo::release_values() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.IOInfo.values)
  
  return values_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IOInfo::set_allocated_values(::std::string* values) {
  if (values != NULL) {
    
  } else {
    
  }
  values_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), values);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.IOInfo.values)
}

// string shapes = 2;
inline void IOInfo::clear_shapes() {
  shapes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IOInfo::shapes() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.IOInfo.shapes)
  return shapes_.GetNoArena();
}
inline void IOInfo::set_shapes(const ::std::string& value) {
  
  shapes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.IOInfo.shapes)
}
#if LANG_CXX11
inline void IOInfo::set_shapes(::std::string&& value) {
  
  shapes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.IOInfo.shapes)
}
#endif
inline void IOInfo::set_shapes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  shapes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.IOInfo.shapes)
}
inline void IOInfo::set_shapes(const char* value, size_t size) {
  
  shapes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.IOInfo.shapes)
}
inline ::std::string* IOInfo::mutable_shapes() {
  
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.IOInfo.shapes)
  return shapes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IOInfo::release_shapes() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.IOInfo.shapes)
  
  return shapes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IOInfo::set_allocated_shapes(::std::string* shapes) {
  if (shapes != NULL) {
    
  } else {
    
  }
  shapes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shapes);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.IOInfo.shapes)
}

// string types = 3;
inline void IOInfo::clear_types() {
  types_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IOInfo::types() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.IOInfo.types)
  return types_.GetNoArena();
}
inline void IOInfo::set_types(const ::std::string& value) {
  
  types_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.IOInfo.types)
}
#if LANG_CXX11
inline void IOInfo::set_types(::std::string&& value) {
  
  types_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.IOInfo.types)
}
#endif
inline void IOInfo::set_types(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  types_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.IOInfo.types)
}
inline void IOInfo::set_types(const char* value, size_t size) {
  
  types_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.IOInfo.types)
}
inline ::std::string* IOInfo::mutable_types() {
  
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.IOInfo.types)
  return types_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IOInfo::release_types() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.IOInfo.types)
  
  return types_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IOInfo::set_allocated_types(::std::string* types) {
  if (types != NULL) {
    
  } else {
    
  }
  types_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), types);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.IOInfo.types)
}

// -------------------------------------------------------------------

// Tensor

// uint64 tensor_id = 1;
inline void Tensor::clear_tensor_id() {
  tensor_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Tensor::tensor_id() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.tensor_id)
  return tensor_id_;
}
inline void Tensor::set_tensor_id(::google::protobuf::uint64 value) {
  
  tensor_id_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.tensor_id)
}

// uint64 storage_id = 2;
inline void Tensor::clear_storage_id() {
  storage_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Tensor::storage_id() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.storage_id)
  return storage_id_;
}
inline void Tensor::set_storage_id(::google::protobuf::uint64 value) {
  
  storage_id_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.storage_id)
}

// uint64 offset = 3;
inline void Tensor::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Tensor::offset() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.offset)
  return offset_;
}
inline void Tensor::set_offset(::google::protobuf::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.offset)
}

// uint64 num_elem = 4;
inline void Tensor::clear_num_elem() {
  num_elem_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Tensor::num_elem() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.num_elem)
  return num_elem_;
}
inline void Tensor::set_num_elem(::google::protobuf::uint64 value) {
  
  num_elem_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.num_elem)
}

// uint64 elem_bytes = 5;
inline void Tensor::clear_elem_bytes() {
  elem_bytes_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Tensor::elem_bytes() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.elem_bytes)
  return elem_bytes_;
}
inline void Tensor::set_elem_bytes(::google::protobuf::uint64 value) {
  
  elem_bytes_ = value;
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.elem_bytes)
}

// string device = 6;
inline void Tensor::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tensor::device() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.device)
  return device_.GetNoArena();
}
inline void Tensor::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.device)
}
#if LANG_CXX11
inline void Tensor::set_device(::std::string&& value) {
  
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ChakraProtoMsg.Tensor.device)
}
#endif
inline void Tensor::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.Tensor.device)
}
inline void Tensor::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.Tensor.device)
}
inline ::std::string* Tensor::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Tensor.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tensor::release_device() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Tensor.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tensor::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Tensor.device)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ChakraProtoMsg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ChakraProtoMsg::NodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChakraProtoMsg::NodeType>() {
  return ::ChakraProtoMsg::NodeType_descriptor();
}
template <> struct is_proto_enum< ::ChakraProtoMsg::CollectiveCommType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChakraProtoMsg::CollectiveCommType>() {
  return ::ChakraProtoMsg::CollectiveCommType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_et_5fdef_2eproto
